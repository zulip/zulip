# Generated by Django 5.2.4 on 2025-08-17 00:11

import hashlib
from typing import Any

from django.db import migrations, transaction
from django.db.backends.base.schema import BaseDatabaseSchemaEditor
from django.db.migrations.state import StateApps
from django.db.models import Q

BATCH_SIZE = 5000
PERSONAL_RECIPIENT = 1
DIRECT_MESSAGE_GROUP_RECIPIENT = 3


def backfill_update_recipient_type_of_personal_messages_to_dm_group(
    apps: StateApps, schema_editor: BaseDatabaseSchemaEditor
) -> None:
    print()

    Draft = apps.get_model("zerver", "Draft")
    ScheduledMessage = apps.get_model("zerver", "ScheduledMessage")
    Message = apps.get_model("zerver", "Message")
    ArchivedMessage = apps.get_model("zerver", "ArchivedMessage")

    for message_model in [Draft, ScheduledMessage, Message, ArchivedMessage]:
        while True:
            num_of_messages = message_model.objects.filter(
                recipient__type=PERSONAL_RECIPIENT
            ).count()
            if num_of_messages > 0:
                print(f"{message_model.__name__}: Detected {num_of_messages} personal messages.")
                num_of_messages_updated = 0
                while num_of_messages_updated < num_of_messages:
                    num_of_messages_updated += do_update_recipient_type_for_batch(
                        apps, message_model
                    )
                    print(
                        f"{message_model.__name__}: Updated {num_of_messages_updated / num_of_messages:.2%} messages."
                    )
            else:
                print(f"{message_model.__name__}: Migration completed.")
                break


def is_draft_model(message_model: Any) -> bool:
    return message_model.__name__ == "Draft"


def get_direct_message_group_hash(id_list: list[int]) -> str:
    """
    Takes a list of user IDs and returns a hash for the group consisting of
    these users. This is used to create a unique identifier for direct message groups.

    This function is copied from zerver/model/recipients.py to avoid import issues.
    """
    sorted_ids = sorted(id_list)
    hash_key = ",".join(str(x) for x in sorted_ids)
    return hashlib.sha1(hash_key.encode()).hexdigest()


def get_or_create_direct_message_group(apps: StateApps, id_list: list[int]) -> Any:
    """
    Takes a list of user IDs and returns the DirectMessageGroup object for
    the group consisting of these users. If the DirectMessageGroup object
    does not yet exist, it will be transparently created.

    This function is copied from zerver/model/recipients.py to avoid import issues.
    """
    DirectMessageGroup = apps.get_model("zerver", "DirectMessageGroup")
    Recipient = apps.get_model("zerver", "Recipient")
    Subscription = apps.get_model("zerver", "Subscription")
    UserProfile = apps.get_model("zerver", "UserProfile")

    direct_message_group_hash = get_direct_message_group_hash(id_list)
    with transaction.atomic(savepoint=False):
        direct_message_group, created = DirectMessageGroup.objects.get_or_create(
            huddle_hash=direct_message_group_hash,
            group_size=len(id_list),
        )
        if created:
            recipient = Recipient.objects.create(
                type_id=direct_message_group.id, type=DIRECT_MESSAGE_GROUP_RECIPIENT
            )
            direct_message_group.recipient = recipient
            direct_message_group.save(update_fields=["recipient"])
            subs_to_create = [
                Subscription(
                    recipient=recipient,
                    user_profile_id=user_profile_id,
                    is_user_active=is_active,
                )
                for user_profile_id, is_active in UserProfile.objects.filter(id__in=id_list)
                .distinct("id")
                .values_list("id", "is_active")
            ]
            Subscription.objects.bulk_create(subs_to_create)
        return direct_message_group


def do_update_recipient_type_for_batch(apps: StateApps, message_model: Any) -> int:
    processed_conversations = set()
    messages_updated = 0

    sender_column_name = "user_profile" if is_draft_model(message_model) else "sender"
    personal_messages = message_model.objects.filter(
        recipient__type=PERSONAL_RECIPIENT
    ).prefetch_related("recipient", sender_column_name)[:BATCH_SIZE]

    for message in personal_messages:
        recipient = message.recipient
        sender = message.user_profile if is_draft_model(message_model) else message.sender

        if (sender.id, recipient.id) in processed_conversations:
            continue

        id_list = [sender.id, recipient.type_id] if sender.id != recipient.type_id else [sender.id]
        direct_message_group = get_or_create_direct_message_group(apps, id_list)

        conditions = (
            (
                Q(user_profile_id=sender.id, recipient_id=recipient.id)
                | Q(user_profile_id=recipient.type_id, recipient_id=sender.recipient_id)
            )
            if is_draft_model(message_model)
            else (
                Q(sender_id=sender.id, recipient_id=recipient.id)
                | Q(sender_id=recipient.type_id, recipient_id=sender.recipient_id)
            )
        )
        messages_updated += message_model.objects.filter(conditions).update(
            recipient_id=direct_message_group.recipient_id
        )

        processed_conversations.add((sender.id, recipient.id))
        processed_conversations.add((recipient.type_id, sender.recipient_id))

    return messages_updated


class Migration(migrations.Migration):
    atomic = False

    dependencies = [
        ("zerver", "0771_alter_realmemoji_author"),
    ]

    operations = [
        migrations.RunPython(
            backfill_update_recipient_type_of_personal_messages_to_dm_group,
            reverse_code=migrations.RunPython.noop,
            elidable=True,
        ),
    ]
