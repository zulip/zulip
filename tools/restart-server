#!/usr/bin/env python
import os
import sys
import pwd
import subprocess
import pylibmc
import traceback
import logging
import time
from humbug_tools import ENDC, WARNING, OKGREEN, DEPLOYMENTS_DIR

logging.basicConfig(format="%(asctime)s restart-server: %(message)s",
                    level=logging.INFO)

deploy_path = os.path.realpath(os.path.join(os.path.dirname(__file__), '..'))
os.chdir(deploy_path)

if os.path.exists("/etc/humbug-server"):
    with open("/etc/humbug-machinetype") as mtf:
        if pwd.getpwuid(os.getuid())[0] != "humbug":
            logging.error("Must be run as user 'humbug'.")
            sys.exit(1)

# Send a statsd event on restarting the server
subprocess.check_call(["python", "./manage.py", "send_stats", "incr", "events.server_restart", str(int(time.time()))])

logging.info("Filling memcached caches")
subprocess.check_call(["python", "./manage.py", "fill_memcached_caches"])

# Restart the FastCGI and related processes via supervisorctl.  We
# minimize downtime by restarting Django and Tornado separately from
# the other worker processes.
logging.info("Killing daemons")
subprocess.check_call(["supervisorctl", "stop",    "humbug-workers:*"])
subprocess.check_call(["supervisorctl", "stop",    "humbug-django"])
subprocess.check_call(["supervisorctl", "stop", "humbug-tornado"])

subprocess.check_call(["ln", '-nsf', deploy_path, os.path.join(DEPLOYMENTS_DIR, "current")])

subprocess.check_call(["supervisorctl", "start", "humbug-tornado"])
subprocess.check_call(["supervisorctl", "start",   "humbug-django"])
subprocess.check_call(["supervisorctl", "start",   "humbug-workers:*"])

logging.info("Done!")
print OKGREEN + "Application restarted successfully!" + ENDC
