import $ from "jquery";
import assert from "minimalistic-assert";
import type * as tippy from "tippy.js";

import * as channel from "./channel.ts";
import * as compose_actions from "./compose_actions.ts";
import * as compose_paste from "./compose_paste.ts";
import * as compose_recipient from "./compose_recipient.ts";
import * as compose_state from "./compose_state.ts";
import * as compose_ui from "./compose_ui.ts";
import * as copy_messages from "./copy_messages.ts";
import * as fenced_code from "./fenced_code.ts";
import * as hash_util from "./hash_util.ts";
import {$t} from "./i18n.ts";
import * as inbox_ui from "./inbox_ui.ts";
import * as inbox_util from "./inbox_util.ts";
import * as message_lists from "./message_lists.ts";
import {type Message, single_message_content_schema} from "./message_store.ts";
import * as message_store from "./message_store.ts";
import * as narrow_state from "./narrow_state.ts";
import * as people from "./people.ts";
import * as recent_view_ui from "./recent_view_ui.ts";
import * as recent_view_util from "./recent_view_util.ts";
import * as rows from "./rows.ts";
import * as stream_data from "./stream_data.ts";
import * as unread_ops from "./unread_ops.ts";
import * as util from "./util.ts";
import * as message_fetch from './message_fetch.ts'

type QuoteMessageOpts = {
    message_id?: number;
    quote_content?: string | undefined;
    keep_composebox_empty?: boolean;
    reply_type?: "personal";
    trigger?: string;
    forward_message?: boolean;
};

const quoting_placeholder = $t({defaultMessage: "[Quotingâ€¦]"});
export let respond_to_message = (opts: {
    keep_composebox_empty?: boolean;
    message_id?: number;
    reply_type?: "personal";
    trigger?: string;
}): void => {
    let message;
    let msg_type: "private" | "stream";
    if (recent_view_util.is_visible()) {
        message = recent_view_ui.get_focused_row_message();
        if (message === undefined) {
            // Open empty compose with nothing pre-filled since
            // user is not focused on any table row.
            compose_actions.start({
                message_type: "stream",
                trigger: "recent_view_nofocus",
                keep_composebox_empty: opts.keep_composebox_empty,
            });
            return;
        }
    } else if (inbox_util.is_visible()) {
        const message_opts = inbox_ui.get_focused_row_message();
        if (message_opts.message === undefined) {
            // If the user is not focused on inbox header, msg_type
            // is not defined, so we open empty compose with nothing prefilled.
            compose_actions.start({
                message_type: message_opts.msg_type ?? "stream",
                trigger: "inbox_nofocus",
                ...message_opts,
                keep_composebox_empty: opts.keep_composebox_empty,
            });
            return;
        }
        message = message_opts.message;
    } else {
        assert(message_lists.current !== undefined);

        message =
            (opts.message_id === undefined
                ? undefined
                : message_lists.current.get(opts.message_id)) ??
            message_lists.current.selected_message();

        if (message === undefined) {
            // empty narrow implementation
            if (
                !narrow_state.narrowed_by_pm_reply() &&
                !narrow_state.narrowed_by_stream_reply() &&
                !narrow_state.narrowed_by_topic_reply()
            ) {
                compose_actions.start({
                    message_type: "stream",
                    trigger: "empty_narrow_compose",
                    keep_composebox_empty: opts.keep_composebox_empty,
                });
                return;
            }

            const narrow_stream_id = narrow_state.stream_id();
            if (narrow_stream_id && !stream_data.is_subscribed(narrow_stream_id)) {
                compose_actions.start({
                    message_type: "stream",
                    trigger: "empty_narrow_compose",
                    keep_composebox_empty: opts.keep_composebox_empty,
                });
                return;
            }

            // Set msg_type to stream by default in the case of an empty
            // home view.
            msg_type = "stream";
            if (narrow_state.narrowed_by_pm_reply()) {
                msg_type = "private";
            }

            const new_opts = compose_actions.fill_in_opts_from_current_narrowed_view({
                ...opts,
                message_type: msg_type,
            });
            compose_actions.start({
                ...new_opts,
                keep_composebox_empty: opts.keep_composebox_empty,
            });
            return;
        }

        if (message_lists.current.can_mark_messages_read()) {
            unread_ops.notify_server_message_read(message);
        }
    }

    // Important note: A reply_type of 'personal' is for the R hotkey
    // (replying to a message's sender with a direct message). All
    // other replies can just copy message.type.
    if (opts.reply_type === "personal" || message.type === "private") {
        msg_type = "private";
    } else {
        msg_type = message.type;
    }

    let stream_id: number | undefined;
    let topic = "";
    let private_message_recipient_ids: number[] | undefined;
    if (msg_type === "stream") {
        assert(message.type === "stream");
        stream_id = message.stream_id;
        topic = message.topic;
    } else if (opts.reply_type === "personal") {
        // reply_to for direct messages is everyone involved, so for
        // personals replies we need to set the direct message
        // recipient to just the sender
        private_message_recipient_ids = [message.sender_id];
    } else {
        private_message_recipient_ids = people.pm_with_user_ids(message);
    }

    compose_actions.start({
        message_type: msg_type,
        stream_id,
        topic,
        ...(private_message_recipient_ids !== undefined && {private_message_recipient_ids}),
        ...(opts.trigger !== undefined && {trigger: opts.trigger}),
        is_reply: true,
        keep_composebox_empty: opts.keep_composebox_empty,
    });
};

export function rewire_respond_to_message(value: typeof respond_to_message): void {
    respond_to_message = value;
}

export function reply_with_mention(opts: {
    keep_composebox_empty?: boolean;
    message_id?: number;
    reply_type?: "personal";
    trigger?: string;
}): void {
    assert(message_lists.current !== undefined);
    respond_to_message({
        ...opts,
        keep_composebox_empty: true,
    });
    const message = message_lists.current.selected_message();
    assert(message !== undefined);
    const mention = people.get_mention_syntax(message.sender_full_name, message.sender_id);
    compose_ui.insert_syntax_and_focus(mention);
}

export let get_highlighted_message_ids = (
    selection = window.getSelection(),
): number[] | undefined => {
    // Returns the message_ids for a selection.
    assert(selection !== null);
    if (!selection.toString()) {
        return undefined;
    }
    const {start_id, end_id} = copy_messages.analyze_selection(selection);
    // Unlikely to ever occur.
    if (start_id === undefined && end_id === undefined) {
        return undefined;
    }
    // This is a weird case and we should fallback to quoting
    // the selected message.
    if (start_id === undefined || end_id === undefined) {
        return undefined;
    }
    return rows.get_ids_in_range(start_id, end_id);
};

export function rewire_get_highlighted_message_ids(
    value: typeof get_highlighted_message_ids,
): void {
    get_highlighted_message_ids = value;
}

function get_quote_target_for_single_message(opts: {
    message_id?: number;
    quote_content?: string | undefined;
}): {
    message_id: number;
    message: Message;
    quote_content: string | undefined;
} {
    assert(message_lists.current !== undefined);
    let message_id;
    let quote_content;
    if (opts.message_id) {
        // If triggered via the message actions popover
        message_id = opts.message_id;
        if (opts.quote_content) {
            quote_content = opts.quote_content;
        }
    } else {
        // If triggered via hotkey
        const highlighted_message_ids = get_highlighted_message_ids();
        if (highlighted_message_ids) {
            // If the current content selection is entirely within a message,
            // we quote that selection.
            message_id = util.the(highlighted_message_ids);
            quote_content = get_message_selection();
        } else {
            // Else we pick the currently focused message.
            message_id = message_lists.current.selected_id();
        }
    }
    const message = message_lists.current.get(message_id);
    assert(message !== undefined);
    // If we don't have quote_content yet (either because there was no valid
    // in-message selection, or because the caller only supplied a message_id),
    // fall back to quoting the entire message using its cached
    // raw_content (Zulip-flavored markdown), if it is available.
    // In case of selections that aren't contained within a single message, we
    // quote the raw_content of the currently focused message.
    quote_content ??= message.raw_content;
    return {message_id, message, quote_content};
}

function get_textarea(opts: QuoteMessageOpts): JQuery<HTMLTextAreaElement> {
    // If the last compose type textarea focused on is still in the DOM, we add
    // the quote in that textarea, else we default to the compose box.
    const last_focused_compose_type_input = compose_state.get_last_focused_compose_type_input();
    const $textarea =
        last_focused_compose_type_input?.isConnected && !opts.forward_message
            ? $(last_focused_compose_type_input)
            : $<HTMLTextAreaElement>("textarea#compose-textarea");
    return $textarea;
}

function setup_compose_to_forward_single_message(message: Message, opts: QuoteMessageOpts): void {
    let topic = "";
    let stream_id: number | undefined;
    if (message.is_stream) {
        topic = message.topic;
        stream_id = message.stream_id;
    }
    compose_state.set_is_processing_forward_message(true);
    compose_actions.start({
        message_type: message.type,
        topic,
        keep_composebox_empty: opts.keep_composebox_empty,
        content: quoting_placeholder,
        stream_id,
        private_message_recipient_ids: [],
    });
    compose_recipient.toggle_compose_recipient_dropdown();
}

function setup_compose_to_quote_single_message(message_id: number, opts: QuoteMessageOpts): void {
    if (
        get_textarea(opts).attr("id") === "compose-textarea" &&
        !compose_state.has_message_content()
    ) {
        // Whether or not the compose box is open, it's empty, so
        // we start a new message replying to the quoted message.
        respond_to_message({
            ...opts,
            // Critically, we pass the message_id of the message we
            // just quoted, to avoid incorrectly replying to an
            // unrelated selected message in interleaved views.
            message_id,
            keep_composebox_empty: true,
        });
    }

    compose_ui.insert_syntax_and_focus(quoting_placeholder, get_textarea(opts), "block");
}

function replace_content(message: Message, raw_content: string, opts: QuoteMessageOpts): void {
    // Final message looks like:
    //     @_**Iago|5** [said](link to message):
    //     ```quote
    //     message content
    //     ```
    // Keep syntax in sync with zerver/lib/reminders.py
    let content = $t(
        {defaultMessage: "{username} [said]({link_to_message}):"},
        {
            username: `@_**${message.sender_full_name}|${message.sender_id}**`,
            link_to_message: hash_util.by_conversation_and_time_url(message),
        },
    );
    content += "\n";
    const fence = fenced_code.get_unused_fence(raw_content);
    content += `${fence}quote\n${raw_content}\n${fence}`;

    compose_ui.replace_syntax(
        quoting_placeholder,
        content,
        get_textarea(opts),
        opts.forward_message,
    );
    compose_ui.autosize_textarea(get_textarea(opts));

    if (!opts.forward_message) {
        return;
    }
    const select_recipient_widget: tippy.ReferenceElement | undefined = $(
        "#compose_select_recipient_widget",
    )[0];
    if (select_recipient_widget !== undefined) {
        void select_recipient_widget._tippy?.popperInstance?.update();
    }
}

function is_quoting_single_message(opts: QuoteMessageOpts): boolean {
    if (opts.message_id) {
        return true;
    }
    const highlighted_message_ids = get_highlighted_message_ids();
    return highlighted_message_ids === undefined || highlighted_message_ids.length === 1;
}

export function quote_message(opts: QuoteMessageOpts): void {
    if (is_quoting_single_message(opts)) {
        quote_single_message(opts);
    }
}

type QuoteAsset = {
    message:Message,
    quote_content:string
}

async function maybe_hydrate_messages_with_raw_content(message_ids:number[]){
    const message_ids_with_missing_raw_content = message_ids.filter((id)=>{
        const message = message_store.get(id);
        if(message?.raw_content){
            return false;
        }
        return true;
    })

    if(message_ids_with_missing_raw_content.length === 0)return;

    await channel.get({
        url: "/json/messages/",
        data: {allow_empty_topic_name: true, apply_markdown: false, message_ids:message_ids_with_missing_raw_content},
        success(raw_data) {
            const data = message_fetch.response_schema.parse(raw_data);
            for(const raw_message of data.messages){
                const cached_message = message_store.get(raw_message.id);
                const fetched_message = single_message_content_schema.shape.message.parse(raw_message)
                assert(cached_message!== undefined && fetched_message.content_type === "text/x-markdown");
                message_store.maybe_update_raw_content(cached_message, fetched_message.content);
            }
        },
        timeout:1000
    });
}

async function get_quote_assets_for_highlighted_messages(highlighted_msg_ids:number[]){
    const quote_assets:QuoteAsset[] = []
    await maybe_hydrate_messages_with_raw_content(highlighted_msg_ids)
    for(const id of highlighted_msg_ids){
        const cached_message = message_store.get(id);
        assert(cached_message!==undefined)
        if(cached_message.raw_content){
            quote_assets.push({
                message:cached_message, quote_content:cached_message.raw_content, 
            });
        }else{
            // Fallback to using markdown obtained by local turndown setup.
            quote_assets.push({
                message:cached_message, quote_content:compose_paste.paste_handler_converter(cached_message.content), 
            })
        }
    }
    return quote_assets
}


function quote_single_message(opts: QuoteMessageOpts): void {
    const {message_id, message, quote_content} = get_quote_target_for_single_message(opts);
    if (opts.forward_message) {
        setup_compose_to_forward_single_message(message, opts);
    } else {
        setup_compose_to_quote_single_message(message_id, opts);
    }

    if (message && quote_content) {
        replace_content(message, quote_content, opts);
        return;
    }

    void channel.get({
        url: "/json/messages/" + message_id,
        data: {allow_empty_topic_name: true, apply_markdown: false},
        success(raw_data) {
            const data = single_message_content_schema.parse(raw_data);
            assert(data.message.content_type === "text/x-markdown");
            message_store.maybe_update_raw_content(message, data.message.content);
            replace_content(message, data.message.content, opts);
        },
        // We set a timeout here to trigger usage of the fallback markdown via the
        // error callback below, which is much better UX than waiting for 10 seconds and
        // feeling that the quoting mechanism is broken.
        timeout: 1000,
        error() {
            // We fall back to using the available message content and pass it
            // through the `paste_handler_converter` to generate the replacement
            // markdown, in case the request timed out or failed for another reason,
            // such as the client being offline.
            const message_html = message.content;
            // We try to access message.raw_content one last time here, just in case
            // it was populated during the waiting time.
            const md = message.raw_content ?? compose_paste.paste_handler_converter(message_html);
            replace_content(message, md, opts);
        },
    });
}

function extract_range_html(range: Range, preserve_ancestors = false): string {
    // Returns the html of the range as a string, optionally preserving 2
    // levels of ancestors.
    const temp_div = document.createElement("div");
    if (!preserve_ancestors) {
        temp_div.append(range.cloneContents());
        return temp_div.innerHTML;
    }
    const container =
        range.commonAncestorContainer instanceof HTMLElement
            ? range.commonAncestorContainer
            : range.commonAncestorContainer.parentElement;
    assert(container !== null);
    assert(container.parentElement !== null);
    // The reason for preserving 2, not just 1, ancestors is code blocks; a
    // selection completely inside a code block has a code element as its
    // container element, inside a pre element, which is needed to identify
    // the selection as being part of a code block as opposed to inline code.
    const outer_container = container.parentElement.cloneNode();
    assert(outer_container instanceof HTMLElement); // https://github.com/microsoft/TypeScript/issues/283
    const container_clone = container.cloneNode();
    assert(container_clone instanceof HTMLElement); // https://github.com/microsoft/TypeScript/issues/283
    container_clone.append(range.cloneContents());
    outer_container.append(container_clone);
    temp_div.append(outer_container);
    return temp_div.innerHTML;
}

function get_range_intersection_with_element(range: Range, element: Node): Range {
    // Returns a new range that is a subset of range and is inside element.
    const intersection = document.createRange();
    intersection.selectNodeContents(element);

    if (intersection.compareBoundaryPoints(Range.START_TO_START, range) < 0) {
        intersection.setStart(range.startContainer, range.startOffset);
    }

    if (intersection.compareBoundaryPoints(Range.END_TO_END, range) > 0) {
        intersection.setEnd(range.endContainer, range.endOffset);
    }

    return intersection;
}

export let get_message_selection = (selection = window.getSelection()): string => {
    assert(selection !== null);
    let selected_message_content_raw = "";

    // We iterate over all ranges in the selection, to find the ranges containing
    // the message_content div or its descendants, if any, then convert the html
    // in those ranges to markdown for quoting (firefox can have multiple ranges
    // in one selection), and also compute their combined bounding rect.
    for (let i = 0; i < selection.rangeCount; i = i + 1) {
        let range = selection.getRangeAt(i);
        const range_common_ancestor = range.commonAncestorContainer;
        let html_to_convert = "";
        let message_content;

        // If the common ancestor is the message_content div or its child, we can quote
        // this entire range at least.
        if (
            range_common_ancestor instanceof Element &&
            range_common_ancestor.classList.contains("message_content")
        ) {
            html_to_convert = extract_range_html(range);
        } else if ($(range_common_ancestor).parents(".message_content").length > 0) {
            // We want to preserve the structure of the html with 2 levels of
            // ancestors (to retain code block / list formatting) in such a range.
            html_to_convert = extract_range_html(range, true);
        } else if (
            // If the common ancestor contains the message_content div, we can quote the part
            // of this range that is in the message_content div, if any.
            range_common_ancestor instanceof Element &&
            (message_content = range_common_ancestor.querySelector(".message_content")) !== null &&
            range.cloneContents().querySelector(".message_content")
        ) {
            // Narrow down the range to the part that is in the message_content div.
            range = get_range_intersection_with_element(range, message_content);
            html_to_convert = extract_range_html(range);
        } else {
            continue;
        }
        const markdown_text = compose_paste.paste_handler_converter(html_to_convert);
        selected_message_content_raw = selected_message_content_raw + "\n" + markdown_text;
    }
    selected_message_content_raw = selected_message_content_raw.trim();
    return selected_message_content_raw;
};

export function rewire_get_message_selection(value: typeof get_message_selection): void {
    get_message_selection = value;
}

export function initialize(): void {
    $("body").on("click", ".compose_reply_button", () => {
        respond_to_message({trigger: "reply button"});
    });
}
